\chapter{数据结构}

%---------------------------------------
\section{花式打表}\small
%---------------------------------------


%---------------------------------------
	\subsection{并查集}\small
%---------------------------------------
维护一个数据结构, 支持两种操作: 合并两个集合, 查询一个元素所处的集合.

维护一个森林, 每一棵树表示一个集合, 树根元素为这个集合的代表元. 数组
{\tt father[]} 维护每一个元素的父节点. 在查询时, 只需要不断寻找父节点, 即可以找
到该元素所处集合的代表元. 在合并时, 先找到这两个集合的代表元 x, y, 然后令
{\tt father[x] := y} 即可. 优化 1: 路径压缩, 在沿着树根的路径找到某一元素 a 的所
在集合的代表元 b 时, 将路径上的所有元素 x 直接进行 {\tt father[x] := b} 操作. 优
化 2: 启发式合并, 用数组 {\tt rank[]} 维护集合的高度, 每次将较小的集合合并到较大
的集合上, 而合并两个相同高度的集合时更新高度.

\begin{longtable}{c|l|l}
\multicolumn{3}{c}{{\tt DisjointSet<Max\_Size>}} \\ \hline\hline
\multicolumn{3}{l}{成员变量} \\ \hline
& \verb`int Max_Size` & 初始化最大容量 \\
& \verb`int fa[]` & 元素的父节点 \\
& \verb`int rk[]` & 集合的高度, rank \\
\hline
\multicolumn{3}{l}{成员函数} \\ \hline
$O(n)$ & \verb`void init(n)` & 初始化并查集, n 个独立元素 \\
$O(1)$ & \verb`int find(x)` & 查找 x 所在集合的代表元 \\
$O(1)$ & \verb`bool query(x, y)` & x, y 是否在同一集合 \\
$O(1)$ & \verb`void merge(x, y)` & 合并 x, y 两个集合 \\
\hline\hline
\end{longtable}

\lstinputlisting[language={C++}]{./src/ch02/0201-DisjointSet.cpp}


%---------------------------------------
	\subsection{块状链表}\small
%---------------------------------------
%------------------------------------------------------------------------------%
维护一个数据结构, 支持插入, 删除, 查询等操作, 同时要求时间复杂度均摊尽可能小.

构造一种块状链表的数据结构, 链表的每一个节点存储一个块, 块内包含数组和所需要维护
的必要数据. 如果整个数据量为 $N$, 链表的规模为 $n$, 每一个块的大小为 $m$, 则显然
满足等式 $N = n \times m$. 则插入, 删除, 查询操作都可以通过遍历块状链表确定操作
块, 然后在块内进行操作来完成. 故三种操作的时间复杂度均为 $O(n + m)$. 一般地, 可
以将 $n = m = \sqrt{N}$, 这样均摊时间复杂度为 $O(\sqrt{N})$.

对于所有操作, 均要求所有块的大小尽可能维持在 $\sqrt{N}$ 与 $2\sqrt{N}$ 之间. 这
样可以保证 $n \leq \sqrt{N}$, 从而保证时间复杂度. 对于插入操作, 如果插入后的块的
大小超过了 $2\sqrt{N}$, 应当分割为两个大小相等的块. 对于删除与查询操作, 由于元素
数量不增加, 所以不会提高时间复杂度.

如果需要额外维护数据, 需要找出所维护的数据在插入与删除操作中的具体变化. 例如要求
维护最值: 在插入元素时, \verb`maintain := op(maintain, x)`, 如果发生了块分裂则重
新统计各个块的最值; 在删除元素时, 除非删除元素恰为最值, 否则不需要重新统计维护.

如果不涉及额外维护操作, 则可以根据不同的操作的工作量确定更小操作常数的方法. 例如
可以将朴素的 $O(\sqrt{N})$ 的可以改进为 $O(\log N)$ 的二分查找, 但是需要在每次插
入和删除操作时额外耗费 $O(\sqrt{N})$ 的操作以建立块的大小的前缀和数组. 假设共有
$M$ 次插入删除操作, $Q$次独立的查询操作, 开始时块状链表的大小为 $N$, 那么全体操
作的时间复杂度上限为 $O((M + Q)\sqrt{N + M})$, 而添加了二分操作后的时间复杂度上
限为 $O(M\sqrt{N + M}) + O((M + Q)\log (N + M) \sqrt{N + M})$. 另外注意此时要求
使用 \verb`vector<Block<Tp> > fat` 而非原始的 \verb`list<Block<Tp> > fat`.

\begin{longtable}{c|l|l}
\multicolumn{3}{c}{{\tt Block<Tp>}} \\ \hline\hline
\multicolumn{3}{l}{成员变量} \\ \hline
& \verb`vector<Tp> arr` & 块内数组 \\
& \verb`Tp maintain` & 块内维护数据 \\
\hline
\multicolumn{3}{l}{成员函数} \\ \hline
$O(1)$ & \verb`Block(Tp val)` & 构造函数, 只包含一个元素 val \\
$O(len)$ & \verb`Block(vector<Tp> vals)` & 构造函数, 复制整个数组 vals \\
\hline\hline
\multicolumn{3}{c}{{\tt BlockList<Tp>}}\\ \hline\hline
\multicolumn{3}{l}{成员变量} \\ \hline
& \verb`list<Block<Tp> > fat` & 块状链表本体 \\
& \verb`vector<int> sum` & 块大小前缀和(不必要) \\
& \verb`int block_capacity` & 块大小上限 \\
& \verb`typedef list<Block<Tp> >::iterator iter` & 块指针数据类型 \\
\hline
\multicolumn{3}{l}{成员函数} \\ \hline
$O(1)$ & \verb`iter next(const iter &_)` & 返回下一个块 \\
$O(1)$ & \verb`int blocksize(const iter &_) ` & 返回块大小 \\
$O(\sqrt{N})$ & \verb`void maintain()` & 维护块大小前缀和(不必要) \\
$O(len)$ & \verb`void init(cap, first, last)` & 从 [first, last) 构造 \\
$O(len)$ & \verb`void init(cap, src, len)` & 从 [src, src+len) 构造 \\
$O(\sqrt{N})$ & \verb`pair<iter, int> get_block(pos)` & 返回 pos 所在块和块内偏移量 \\
$O(\log N)$ & \verb`pair<iter, int> get_block_bs(pos)` & 基于二分查找(不必要) \\
$O(\sqrt{N})$ & \verb`void insert(pos, val)` & 在第 pos 位前插入元素 val \\
$O(\sqrt{N})$ & \verb`void remove(pos)` & 删除第 pos 位的元素 \\
$O(\sqrt{N})$ & \verb`Tp at(pos)` & 查询第 pos 位的元素 \\
$O(N)$ & \verb`void __dbg__()` & 打印整个块状链表 \\
\hline\hline
\end{longtable}

\lstinputlisting[language={C++}]{./src/ch02/0202-BlockList.cpp}

%---------------------------------------
	\subsection{ST表}\small
%---------------------------------------
%------------------------------------------------------------------------------%
维护一个数据结构, 离线查询 $A[l], A[l + 1], \cdots, A[r]$ 的最小值(或最大值).

用 $O(N\log N)$ 的时间预处理出数组 {\tt st[i, j]}, 表示从 $A[i]$ 开始连续
$2^j$ 个元素中的极值. 其状态转移方程为:

\lstinputlisting[language={Haskell}]{./src/ch02/0203-SparseTable.hs}

对于每一次询问, 令 $k = \lfloor \log_2{r - l + 1} \rfloor$, 则闭区间 $[l, r]$
的最小值为 $\min\{ st[l, k], st[r - 2^i + 1, k] \}$.

\begin{longtable}{c|l|l}
\multicolumn{3}{c}{{\tt SparseTable<Tp, Max\_Size>}} \\ \hline\hline
\multicolumn{3}{l}{成员变量} \\ \hline
& \verb`int Max_Size` & 初始化最大容量 \\
& \verb`int preLog2[]` & {\tt preLog2[x]} $=\log_2 x$ \\
& \verb`int a[][]` & {\tt st[][]} \\
\hline
\multicolumn{3}{l}{成员函数} \\ \hline
$O(n)$ & \verb`void init(n)` & 初始化 ST 表, n 个独立元素 \\
$O(n\log n)$ & \verb`void build(first, last)` & 从 [first, last) 构造 \\
$O(n\log n)$ & \verb`void build(src, len)` & 从 [src, src+len) 构造 \\
$O(1)$ & \verb`Tp query(l, r)` & 查询闭区间 $[l, r]$ 的最小值 \\
\hline\hline
\end{longtable}

\lstinputlisting[language={C++}]{./src/ch02/0203-SparseTable.cpp}

如果是二维区域 $[r_1, c_1] \rightarrow [r_2, c_2]$ 的最小值(或最大值), 则预处理出
{\tt st[i, j, ki, kj]}, 表示从 $A[i, j]$ 为端点, 大小为 $[2^ki, 2^kj]$ 的矩形中
所有元素的最小值. 其状态转移方程与一维情形类似. 对于每一次询问, 令
$k_r = \lfloor \log_2{r_2 - r_1 + 1} \rfloor$,
$k_c = \lfloor \log_2{c_2 - c_1 + 1} \rfloor$, $r_x = r_2 - 2^{k_r} + 1$,
$c_x = c_2 - 2^{k_c} + 1$, 则闭区域 $[r_1, c_1] \rightarrow [r_2, c_2]$
的最小值为 $\min \{ st[r_1, c_1, k_r, k_c], st[r_x, c_1, k_r, k_c],
	st[r_1, c_x, k_r, k_c], st[r_x, c_x, k_r, k_c] \}$.

\begin{longtable}{c|l|l}
\multicolumn{3}{c}{{\tt SparseTable2D<Tp, Max\_Size>}} \\ \hline\hline
\multicolumn{3}{l}{成员变量} \\ \hline
& \verb`int Max_Size` & 初始化最大容量 \\
& \verb`int preLog2[]` & {\tt preLog2[x]} $=\log_2 x$ \\
& \verb`int a[][][][]` & {\tt st[][][][]} \\
\hline
\multicolumn{3}{l}{成员函数} \\ \hline
$O(n)$ & \verb`void init(n)` & 初始化 ST 表, n 个独立元素 \\
$O(n^2(\log n)^2)$ & \verb`void build(src, rows, cols)` & 从 {\tt src[]} 构造 \\
$O(1)$ & \verb`Tp query(r1, r2, c1, c2)` & 查询闭区域 $[r_1, c_1] \rightarrow [r_2, c_2]$ 的最小值 \\
\hline\hline
\end{longtable}

\lstinputlisting[language={C++}]{./src/ch02/0203-SparseTable2D.cpp}

\global\csname @topnum\endcsname 0

\begin{figure}[ht]
	\centering
	\begin{tabular}{c|c}
		\makecell{
		{\tt aaaaaaaa.....}\\
		{\tt L...........R}\\
		{\tt .....bbbbbbbb}
		} & \makecell{
		{\tt A....C.A....C}\\
		{\tt |....|.|....|}\\
		{\tt B....D.B....D}\\
		{\tt A....C.A....C}\\
		{\tt |....|.|....|}\\
		{\tt B....D.B....D}
		}
	\end{tabular}
	\caption{イラスト：Sparse Table}\label{fig-stable}
\end{figure}

%---------------------------------------
\section{平衡树}\small
%---------------------------------------


%---------------------------------------
	\subsection{红黑树 RBTree}\small
%---------------------------------------


%---------------------------------------
	\subsection{树堆 Treap}\small
%---------------------------------------


%---------------------------------------
	\subsection{伸展树 Splay}\small
%---------------------------------------


%---------------------------------------
\section{二叉堆}\small
%---------------------------------------


%---------------------------------------
	\subsection{优先队列}\small
%---------------------------------------


%---------------------------------------
	\subsection{左偏树}\small
%---------------------------------------


%---------------------------------------
\section{线段树}\small
%---------------------------------------


%---------------------------------------
	\subsection{树状数组}\small
%---------------------------------------


%---------------------------------------
	\subsection{RMQ 线段树}\small
%---------------------------------------


%---------------------------------------
\section{树链剖分}\small
%---------------------------------------


%---------------------------------------
\section{动态树}\small
%---------------------------------------


%---------------------------------------
\section{手指树}\small
%---------------------------------------


%---------------------------------------
\section{Trie}\small
%---------------------------------------

